//===----------------------------------------------------------------------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2017 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

extension TimeInterval {
    fileprivate init(_ duration: Duration) {
        self = Double(duration.components.seconds) + 1e-18 * Double(duration.components.attoseconds)
    }
}

@available(FoundationPreview 6.2, *)
extension Date: InstantProtocol {
    
    @available(FoundationPreview 6.2, *)
    public func advanced(by duration: Duration) -> Date {
        addingTimeInterval(TimeInterval(duration))
    }
    
    @available(FoundationPreview 6.2, *)
    public func duration(to other: Date) -> Duration {
        .seconds(other.timeIntervalSince(self))
    }
    
    @available(FoundationPreview 6.2, *)
    public static func leapSeconds(from: Date, to: Date) -> Duration {
        /*
         These can be generated by using the calendar APIs and the following:
         let leaps = [
         DateComponents(timeZone: .gmt, year: 1972, month: 6, day: 30, hour: 23, minute: 59, second: 59),
         DateComponents(timeZone: .gmt, year: 1972, month: 12, day: 31, hour: 23, minute: 59, second: 59),
         DateComponents(timeZone: .gmt, year: 1973, month: 12, day: 31, hour: 23, minute: 59, second: 59),
         DateComponents(timeZone: .gmt, year: 1974, month: 12, day: 31, hour: 23, minute: 59, second: 59),
         DateComponents(timeZone: .gmt, year: 1975, month: 12, day: 31, hour: 23, minute: 59, second: 59),
         DateComponents(timeZone: .gmt, year: 1976, month: 12, day: 31, hour: 23, minute: 59, second: 59),
         DateComponents(timeZone: .gmt, year: 1977, month: 12, day: 31, hour: 23, minute: 59, second: 59),
         DateComponents(timeZone: .gmt, year: 1978, month: 12, day: 31, hour: 23, minute: 59, second: 59),
         DateComponents(timeZone: .gmt, year: 1979, month: 12, day: 31, hour: 23, minute: 59, second: 59),
         DateComponents(timeZone: .gmt, year: 1981, month: 6, day: 30, hour: 23, minute: 59, second: 59),
         DateComponents(timeZone: .gmt, year: 1982, month: 6, day: 30, hour: 23, minute: 59, second: 59),
         DateComponents(timeZone: .gmt, year: 1983, month: 6, day: 30, hour: 23, minute: 59, second: 59),
         DateComponents(timeZone: .gmt, year: 1985, month: 6, day: 30, hour: 23, minute: 59, second: 59),
         DateComponents(timeZone: .gmt, year: 1987, month: 12, day: 31, hour: 23, minute: 59, second: 59),
         DateComponents(timeZone: .gmt, year: 1989, month: 12, day: 31, hour: 23, minute: 59, second: 59),
         DateComponents(timeZone: .gmt, year: 1990, month: 12, day: 31, hour: 23, minute: 59, second: 59),
         DateComponents(timeZone: .gmt, year: 1992, month: 6, day: 30, hour: 23, minute: 59, second: 59),
         DateComponents(timeZone: .gmt, year: 1993, month: 6, day: 30, hour: 23, minute: 59, second: 59),
         DateComponents(timeZone: .gmt, year: 1994, month: 6, day: 30, hour: 23, minute: 59, second: 59),
         DateComponents(timeZone: .gmt, year: 1995, month: 12, day: 31, hour: 23, minute: 59, second: 59),
         DateComponents(timeZone: .gmt, year: 1997, month: 6, day: 30, hour: 23, minute: 59, second: 59),
         DateComponents(timeZone: .gmt, year: 1998, month: 12, day: 31, hour: 23, minute: 59, second: 59),
         DateComponents(timeZone: .gmt, year: 2005, month: 12, day: 31, hour: 23, minute: 59, second: 59),
         DateComponents(timeZone: .gmt, year: 2008, month: 12, day: 31, hour: 23, minute: 59, second: 59),
         DateComponents(timeZone: .gmt, year: 2012, month: 6, day: 30, hour: 23, minute: 59, second: 59),
         DateComponents(timeZone: .gmt, year: 2015, month: 6, day: 30, hour: 23, minute: 59, second: 59),
         DateComponents(timeZone: .gmt, year: 2016, month: 12, day: 31, hour: 23, minute: 59, second: 59),
         ]
         for leap in leaps {
         let date = Calendar.current.date(from: leap)!
         let t = date.timeIntervalSinceReferenceDate
         print("if start <= \(t) && \(t) < end { adjustment += .seconds(1) }")
         }
         */
        var adjustment = Duration.seconds(0)
        let start = min(from, to).timeIntervalSinceReferenceDate
        let end = max(from, to).timeIntervalSinceReferenceDate
        if start <= -899510401.0 && -899510401.0 < end { adjustment += .seconds(1) }
        if start <= -883612801.0 && -883612801.0 < end { adjustment += .seconds(1) }
        if start <= -852076801.0 && -852076801.0 < end { adjustment += .seconds(1) }
        if start <= -820540801.0 && -820540801.0 < end { adjustment += .seconds(1) }
        if start <= -789004801.0 && -789004801.0 < end { adjustment += .seconds(1) }
        if start <= -757382401.0 && -757382401.0 < end { adjustment += .seconds(1) }
        if start <= -725846401.0 && -725846401.0 < end { adjustment += .seconds(1) }
        if start <= -694310401.0 && -694310401.0 < end { adjustment += .seconds(1) }
        if start <= -662774401.0 && -662774401.0 < end { adjustment += .seconds(1) }
        if start <= -615513601.0 && -615513601.0 < end { adjustment += .seconds(1) }
        if start <= -583977601.0 && -583977601.0 < end { adjustment += .seconds(1) }
        if start <= -552441601.0 && -552441601.0 < end { adjustment += .seconds(1) }
        if start <= -489283201.0 && -489283201.0 < end { adjustment += .seconds(1) }
        if start <= -410313601.0 && -410313601.0 < end { adjustment += .seconds(1) }
        if start <= -347155201.0 && -347155201.0 < end { adjustment += .seconds(1) }
        if start <= -315619201.0 && -315619201.0 < end { adjustment += .seconds(1) }
        if start <= -268358401.0 && -268358401.0 < end { adjustment += .seconds(1) }
        if start <= -236822401.0 && -236822401.0 < end { adjustment += .seconds(1) }
        if start <= -205286401.0 && -205286401.0 < end { adjustment += .seconds(1) }
        if start <= -157852801.0 && -157852801.0 < end { adjustment += .seconds(1) }
        if start <= -110592001.0 && -110592001.0 < end { adjustment += .seconds(1) }
        if start <= -63158401.0 && -63158401.0 < end { adjustment += .seconds(1) }
        if start <= 157766399.0 && 157766399.0 < end { adjustment += .seconds(1) }
        if start <= 252460799.0 && 252460799.0 < end { adjustment += .seconds(1) }
        if start <= 362793599.0 && 362793599.0 < end { adjustment += .seconds(1) }
        if start <= 457401599.0 && 457401599.0 < end { adjustment += .seconds(1) }
        if start <= 504921599.0 && 504921599.0 < end { adjustment += .seconds(1) }
        if from < to {
            return adjustment
        } else {
            return .seconds(0) - adjustment
        }
    }
    
    @available(FoundationPreview 6.2, *)
    public typealias Duration = Swift.Duration
}

@available(FoundationPreview 6.2, *)
public struct UTCClock: Sendable {
    public typealias Instant = Date
    public init() { }
}

@available(FoundationPreview 6.2, *)
extension UTCClock: Clock {
    @available(FoundationPreview 6.2, *)
    public func sleep(until deadline: Date, tolerance: Duration? = nil) async throws {
        // this needs a runtime function adjustment (for now it is "good enough" until we integrate the wall clock sleep function in the concurrency runtime)
        try await ContinuousClock().sleep(until: .now.advanced(by: .seconds(deadline.timeIntervalSinceNow)), tolerance: tolerance)
    }
    
    @available(FoundationPreview 6.2, *)
    public var now: Date {
        Date()
    }
    
    @available(FoundationPreview 6.2, *)
    public var minimumResolution: Duration {
        .nanoseconds(1)
    }
    
    @available(FoundationPreview 6.2, *)
    public static var systemEpoch: Date {
        Date(timeIntervalSinceReferenceDate: 0)
    }
}
